作成後権限を変更しないとシェルスクリプトをたたけない

# 権限変更
chmod 755 ./shell.sh

# 実行
./shell.sh
sh ./hello.shでも
bash ./hello.shでも実行可能

仮想環境のVagrantディレクトリにtest.shを作成
atomでコーディングしてatom上で実行できるように環境整備

シェルではスペースが大事である
→　スペース1つで正常に動作しない


Linux環境では
#!/bin/shと宣言をしてもbashとしてデフォルトで実行される

コマンドの終了ステータスは
0が真
それ以外が偽
として返却される

単純コマンドとはコマンドと引数をスペースで区切って並べたものである

> 等で別のプロセスへ飛ぶことをリダイレクトという

復号コマンドとは構文、サブシェル、シェル関数などのこと

単純コマンドと復号コマンドを合わせてコマンドという

パイプ(|)で連結されたものは左側の結果を右側へ引き継ぐことができる
→　パイプラインという(このときテンポラリファイルは出力されない)

リストとはパイプラインを改行などで区切って並べたものである

コマンドの最後に&を足すことでバックグラウンドで処理を行う(つけないとフォアグラウンドで処理が行われる)

&&リストでは簡単なif分岐の様に使用できる(&&は両方とも真でなければ評価されないことを利用する)

||リストでも同様に分岐処理が行える(||は片方が真であれば評価されることを利用する)

if文での [ は testコマンドのエイリアスのためスペースが必須である(ないと文字列として評価されてしまう)

select分は選択メニューを表示してユーザー入力を受け付けるコマンドである

サブシェルとはリストをまとめて別のシェルで実行するため本幹の処理に戻った時に変数やカレントディレクトリなどが変更されない()を使用して記述する

グループコマンドとはリストを1つのコマンドとしてまとめるもので別のプロセスで行われるわけでなないのでサブシェルとは異なり本幹の処理に影響が出る
{}を使用して記述する

:コマンドは何もしないで単に0のステータスを返却する(trueの同様のことが行えるがtrueコマンドは外部コマンドのためできるだけ:コマンドを使用する)

falseコマンドでは1のステータスを返却する

.コマンドは現在実行中のシェルに別のシェルスクリプトを読み込ませる(他のファイルに環境変数などを定義しておけば簡単に環境変数を設定することが可能となる)

evalコマンドでは引数を再度解釈しコマンドを実行する

execコマンドでは新しいプロセスを作らずにコマンドを起動する

exitコマンドではシェルスクリプトを終了する(異常終了の際などは引数にステータスを与える)

exportコマンドはシェル変数を環境変数としてエクスポートする(unsetコマンドで変更可能)

getoptsコマンドではシェルスクリプトの引数につけられたオプションを解析する

readonlyコマンドではシェル変数を読み込み専用に設定する(unsetコマンドでも変更できなくなる)

returnコマンドはシェル関数を終了する(引数に終了ステータスを設定することが可能)

setコマンドではシェルにオプションフラグをセットしたり、位置パラメータ($1など)をセットすることができる

shiftコマンドでは位置パラメータをシフトすることができる(引数の数値分シフトする)

trapコマンドではシグナルを受け取った時に指定のコマンドを実行させる(シグナルとはエラー時に発生するものとか)

typeコマンドでは外部コマンドのフルパスを調べたり、組み込みコマンドかどうかをチェックしたりできる

unmaskコマンドではシェル自体のunmask値を設定/表示できる(マスクによって生成されたディレクトリなどのデフォルトの権限が変更できる)

unsetコマンドではシェル変数やシェル関数を削除できる(readonlyは削除できない)

waitコマンドではバックグラウンドで起動したコマンド(&を付与したもの)の終了を待つ(引数にプロセスIDを与える)

sleepコマンドでは処理を引数の数値秒止まらせる

killコマンドではプロセスにシグナルを送る

printfコマンドでは引数で出力するフォーマットを指定して出力する

testコマンドは真偽判定の際に使用され [ でも使用可能
-f で通常ファイルの判定
-d でディレクトリの判定
-r で読み込み可能かの判定
-w で書き込み可能かの判定
などなど

builtinコマンドはシェル関数と同名の組み込み関数を優先的に実行する(通常実行ではシェル関数が優先的に実行されてしまうため)
→　できるだけ組み関数と同じ名前の関数を定義しないこと

commandコマンドではシェル関数と同名の組み込みコマンドまたは外部コマンドを優先的に実行する(builtin同様に通常実行では定義したものが優先的に実行されてしまうため)
→　これもなるべく同名のコマンドを定義しないこと

letコマンドでは算術式を評価する(算術式ではシングルクォートで囲む)

localコマンドではシェル関数内でローカル変数を定義できる(サブシェルを使用する方法でもローカル変数を作り出すことは可能)

変数へのアクセスは$を変数名の先頭に付与することでアクセスすることができる
→　この時ダブルクォートで囲んでアクセスすること(異なった値が参照される場合がある)

"$1"の様にして関数の引数やsetコマンドで設定した値などにアクセスすることができる(これもダブルクォートで囲んで記述すること)
→　位置パラメータという
→　$1から$9まで参照可能それ以降はshiftコマンドを使用してずらしてからアクセスすること
→　位置パラメータに直接値を設定することはできない

すべての引数をまとめて参照する場合は$@を使用する(ダブルクォートで囲んで記述すること)
→　ループの際の引数などで使用される

$*はシェルスクリプトやシェル関数の引数すべてを1つに連結して参照する(ダブルクォートで囲んで記述すること)
→　あまり使用されない

引数の総数は$#で参照可能(ダブルクォートで囲む必要はない)

$0は位置パラメータではなく特殊パラメータであり起動されたシェルスクリプト名を参照する

$?は終了ステータスを参照する(ダブルクォートで囲む必要はない)
→　この特殊パラメータはすぐに上書きされてしまうためコマンド直後に参照すること

$!は最も新しくバックグラウンドで起動したコマンドのプロセスIDを参照する
→　waitコマンドで待機するときやkillコマンドでプロセスを殺すときに使用される

$$はシェル自身のプロセスIDを参照する
→　テンポラリファイルを作成するときに使用される

$-は現在のシェルに設定されているオプションフラグを参照する
→　あまり使用しない

$_は直前に実行したコマンドの最後の引数を参照する
→　あまり使用されない

単純コマンドの左側に環境変数の代入文を記述することで環境変数の一時変更が可能である
(exportを使用すると環境変数の変更が行える)

PATHの設定ではすでにPATHは設定されているため
PATH=追加したいPATH:$PATH
の様にして最後に:つなぎで$PATHを追加する必要がある(こうしないと上書いて消してしまう)
→　echo "$PATH"で確認してからexport PATHすると良い

PS1変数はデフォルトが$、PS2はデフォルトが>である(コマンド入力の際の待ちのときに出力されている部分)
→　基本的に変更しない

HOME変数は自分自身のホームディレクトリが設定されているシェル変数である
→　基本的に変更しない

IFS変数は単語分割に用いられる区切り文字が設定されているシェル変数である(デフォルト値はスペース、タブ、改行の3つである)
→　基本的に変更しない

パラメータ展開とはパラメータを実際の値に展開すること
→　参照する際に何らかの条件判断を行える
→　"$var"と参照するところを"${var:-default}"の様にして参照することでvar変数に値が設定されていない場合のデフォルト値(この場合defaultという文字)を設定することができたりする
→　空文字のデフォルト値は=の右側に何も書かないと空文字に設定できる
→　こっちは展開をする

${パラメータ:=値}の様に設定することでパラメータが設定されていないか空文字のときに値がデフォルト値として設定することができる
→　こっちは代入をする(そのため位置パラメータや特殊パラメータには使用できない)

${パラメータ:?値}は設定されていないか空文字のときに値がエラーメッセージとして出力されてシェルを終了する

${パラメータ:+値}でパラメータが設定されている場合のみ(空文字不可)指定の値に展開をする
→　PATHに値が設定されているかを確認しすでに設定されている場合は:つなぎで入力するために:を展開するように使用される

${#パラメータ}でパラメータの値の文字列の長さを展開する(ダブルクォートで囲む必要なし)
→　wcコマンドで文字数をカウントする方法もある

${パラメータ#パターン}でパラメータの値の文字列の左側から一定のパターンを取り除く(一致する最短の部分を取り除く)
→　${パラメータ##パターン}で一致する最長の部分を取り除く

${パラメータ%パターン}または${パラメータ%%パターン}で右側から一致のパターンを取り除く

${パラメータ:オフセット}または${パラメータ:オフセット:長さ}でオフセットや長さを指定してパラメータの値を切り出す

${パラメータ/パターン/置換文字列}または${パラメータ//パターン/置換文字列}でパターンと一致するものを1か所またはすべて置換する

${!変数名@}または${!変数名*}で指定した文字列で始まる変数名を一覧表示する(シェル変数のみが対象(位置パラメータや特殊パラメータは対象外))

${!パラメータ}でパラメータの値をパラメータ名とみなし、さらにその値を参照する(間接参照)
→　あまり使用されない

クォートにはシングルクォート、ダブルクォート、バックスラッシュがあるがどれもプログラミングのルールと変わりない
→　シングルクォート('')は展開されない、ダブルクォート("")は展開される、バックスラッシュ(\)はエスケープを行う

コマンド置換にはバッククォートと$()の記法が使用される
→　基本的に動作には変わりはないがバックスラッシュの出力方法が少し違う
→　$()記法は使用できない環境も存在しているためバッククォート(``)を使用する

コマンドはパラメータやコマンド置換の終了後に実行される

*を使用してパス名展開をすることができる
→　0文字以上の任意の文字列にマッチさせる
→　ワイルドカードである
→　正規表現ではないことに注意(正規表現では.*に該当する)

?を使用してパス名展開を行った場合は任意の1文字にマッチさせる
→　これもワイルドカードであり正規表現の.に該当する

[a-z]を使用したパス名展開では指定した条件の1文字にマッチさせる
→　[a-z][!a-z]は正規表現では[a-z][^a\z]に該当する
→　[]の中には数字を指定することも可能である
→　!をつけると逆転の判定(補集合での判定)を行うことは今までと同じ

ブレース展開とは複数の文字列の組み合わせから文字列を生成することである
→　{文字列, 文字列, 文字列}の様に設定することで順に展開していく
→　bash環境でしか正常に動作しない
→　規則性のないファイルを一括管理するときなどに便利である
→　{1..9}の様に記述することで連番を展開してくれる

$(())を使用することで算術式展開をすることができる
→　この中では変数の先頭に$を付与しなくて参照できる
→　環境によって使用できないためシェルスクリプトではexprが推奨される

チルダ展開とは~を使用することでユーザーのホームディレクトリに展開をすること
→　環境によって使用できないためシェルスクリプトでは"$HOME"を使用することが推奨される

プロセス置換とはFIFO(名前付きパイプ)に接続した別プロセスを起動しそのFIFO名に置換することである
→　bash環境でも使用できないことがある
→　パイプでも同様に実装することができるため通常のパイプを使用することが多い
→　ここでは省略する

ファイルの記述子
0：標準入力
1：標準出力
2：標準エラー出力

<コマンドではコマンドの標準出力にファイルを入力する

>コマンドではコマンドの標準出力をファイルに出力する

>>コマンドではコマンドの標準出力をファイルに追加で出力する(アペンドモード)

2>コマンドではコマンドの標準エラー出力をファイルに出力する
→　2>>でアペンドモードでエラーの出力を行う
→　2> /dev/nullの様に記述することでエラーメッセージを出力しないように設定可能

>&コマンドでオープン済みの標準出力や標準エラー出力などを複製する
→　echo 'messeages' 1>&2の様にすると標準エラー出力にmessagesを出力することができる
→　2>&1の様に設定するとエラーメッセージお標準出力の両方をリダイレクトするときに使用される
※ 主にこの2種類が使用される

&>コマンドでは標準出力と標準エラー出力の同時リダイレクトをする
→　2>&1と同様だが&>コマンドは環境によって使用できない場合がある

>&-や<&-でファイル識別子をクローズする
→　0<&- 1>&- 2>&-で標準入力、標準出力、標準エラー出力をクローズすることができる

<>コマンドではコマンドのファイル記述子を読み書き両方でオープンしたファイルにリダイレクトする

コマンド << 'EOF'
ドキュメント
EOF
の様にすることでヒアドキュメントを実現できる
→　コマンドの標準入力に一定の文書を入力する
→　パイプで出力することができる
→　環境に左右せず使用できる

コマンド <<< 'ドキュメント'の様に記述することでヒアストリングを実現できる
→　コマンドの標準入力に一定の文字列を入力する
→　環境によって使用できない場合がある

basenameコマンドではファイル名からディレクトリ名部分や拡張子を取り除く

dirnameコマンドではファイル名からそのディレクトリ名部分のみを取りだす

cmpコマンドではファイルの比較を行う

diffコマンドではファイルの差分を抽出する

dateコマンドでは日付と時刻の表示を行う

wcコマンドではファイルの行数、単語数、ファイルサイズを表示する

headコマンドではファイルの先頭部分を表示する

tailコマンドではファイルの末尾部分を表示する

sedコマンドでは正規表現による文字列の置換する

awkコマンドは各種文字列処理ができるスクリプト言語

findコマンドでは一定の条件のファイルの検索を行う

xargsコマンドでは標準入力を引数に取り込んでコマンドを起動する

sleepコマンドでは一定時間停止する

touchコマンドではファイルの更新日付を更新する
→　指定されたファイルが存在しない場合はファイルサイズゼロのファイルを作成する

配列は[]を使用することでプログラミングの様に使用することが可能である
→　配列を参照する場合は"${array[0]}"の様にして参照すること

array=(値 値 値)で一気に配列に設定できる
→　参照するときはarray[@]とすると一気に参照できる

上記の配列コマンドはLinux環境でしか使用できないためほかの環境でも使用できるスクリプトを作成する場合はevalコマンドを使用して配列と同様な処理を行うことが可能である

シェルスクリプトではif文の代わりに&&コマンドや||コマンドを使用するのが定石である

ラッパースクリプトを起動する際は無駄なプロセスを制限するためexecコマンドで起動するのが定石

dateコマンドでは日付や時間を表示するがプログラミング同様に%Y%m%d%H%M%Sの様にして年、月、日、時、分、秒を表現することができる

while readコマンドではファイルを1行ずつ読んでループすることができる
